//! The components to construct an asynchronous HTTP service from the `Endpoint`.

use futures;
use futures::Async::*;
use http::header::{self, HeaderValue};
use http::{Request, Response};
use hyper;
use hyper::server::{NewService, Service};
use slog::Logger;
use std::sync::Arc;
use std::time;
use std::{fmt, io};

use finchers_core::endpoint::{Context, Endpoint};
use finchers_core::error::{HttpError, NoRoute};
use finchers_core::future::{Future, Poll};
use finchers_core::input::{with_set_cx, Input, RequestBody};
use finchers_core::output::{Responder, ResponseBody};

/// A factory of HTTP service which wraps an `Endpoint`.
#[derive(Debug)]
pub struct App<E: Endpoint> {
    data: Arc<AppData<E>>,
}

struct AppData<E: Endpoint> {
    endpoint: E,
    logger: Logger,
    error_handler: ErrorHandler,
}

impl<E: Endpoint + fmt::Debug> fmt::Debug for AppData<E> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("AppData")
            .field("endpoint", &self.endpoint)
            .finish()
    }
}

impl<E: Endpoint> App<E> {
    /// Create a new `App` from the provided components.
    pub fn new(endpoint: E, logger: Logger) -> App<E> {
        App {
            data: Arc::new(AppData {
                endpoint,
                logger,
                error_handler: default_error_handler,
            }),
        }
    }
}

impl<E: Endpoint> NewService for App<E> {
    type Request = hyper::Request;
    type Response = hyper::Response<ResponseBody>;
    type Error = hyper::Error;
    type Instance = AppService<E>;

    fn new_service(&self) -> io::Result<Self::Instance> {
        Ok(AppService {
            data: self.data.clone(),
        })
    }
}

/// An asynchronous HTTP service which holds an `Endpoint`.
///
/// The value of this type is generated by `NewEndpointService`.
#[derive(Debug)]
pub struct AppService<E: Endpoint> {
    data: Arc<AppData<E>>,
}

impl<E: Endpoint> Service for AppService<E> {
    type Request = hyper::Request;
    type Response = hyper::Response<ResponseBody>;
    type Error = hyper::Error;
    type Future = AppServiceFuture<E::Future>;

    fn call(&self, request: Self::Request) -> Self::Future {
        let request = Request::from(request).map(RequestBody::from_hyp);
        let logger = self.data.logger.new(o!{
            "method" => request.method().to_string(),
            "path" => request.uri().path().to_owned(),
        });
        let input = Input::new(request);
        let in_flight = self.data.endpoint.apply(&mut Context::new(&input));

        AppServiceFuture {
            in_flight,
            input,
            logger,
            start: time::Instant::now(),
            error_handler: self.data.error_handler,
        }
    }
}

#[allow(missing_docs)]
#[allow(missing_debug_implementations)]
pub struct AppServiceFuture<T> {
    in_flight: Option<T>,
    input: Input,
    logger: Logger,
    start: time::Instant,
    error_handler: ErrorHandler,
}

impl<T> AppServiceFuture<T> {
    fn handle_error(&self, err: &HttpError) -> Response<ResponseBody> {
        (self.error_handler)(err, &self.input)
    }
}

impl<T> futures::Future for AppServiceFuture<T>
where
    T: Future,
    T::Output: Responder,
{
    type Item = hyper::Response<ResponseBody>;
    type Error = hyper::Error;

    fn poll(&mut self) -> futures::Poll<Self::Item, Self::Error> {
        let output = match {
            let logger = &self.logger;
            let in_flight = &mut self.in_flight;
            let input = &mut self.input;
            LOGGER.set(logger, || match in_flight {
                Some(ref mut f) => with_set_cx(input, || f.poll().map(Some)),
                None => Poll::Ready(None),
            })
        } {
            Poll::Pending => return Ok(NotReady),
            Poll::Ready(Some(output)) => output
                .respond(&self.input)
                .map(|res| res.map(Into::into))
                .map_err(Into::into),
            Poll::Ready(None) => Err(NoRoute.into()),
        };

        let mut response = output.unwrap_or_else(|err| self.handle_error(err.as_http_error()));

        if !response.headers().contains_key(header::SERVER) {
            response.headers_mut().insert(
                header::SERVER,
                HeaderValue::from_static(concat!("finchers-runtime/", env!("CARGO_PKG_VERSION"))),
            );
        }

        let end = time::Instant::now();
        let duration = end - self.start;
        let duration_msec = duration.as_secs() * 10 + duration.subsec_nanos() as u64 / 1_000_000;
        info!(self.logger, "{} ({} ms)", response.status(), duration_msec);

        Ok(Ready(hyper::Response::from(response)))
    }
}

// ==== Logger ====

scoped_thread_local!(static LOGGER: Logger);

/// Execute a closure with the reference to `Logger` associated with the current scope.
pub fn with_logger<F, R>(f: F) -> R
where
    F: FnOnce(&Logger) -> R,
{
    LOGGER.with(|logger| f(logger))
}

// ==== ErrorHandler ====

/// A type alias of the error handler used by `EndpointService`.
pub type ErrorHandler = fn(&HttpError, &Input) -> Response<ResponseBody>;

fn default_error_handler(err: &HttpError, _: &Input) -> Response<ResponseBody> {
    let body = err.to_string();
    let body_len = body.len().to_string();

    let mut response = Response::new(ResponseBody::once(body));
    *response.status_mut() = err.status_code();
    response.headers_mut().insert(
        header::CONTENT_TYPE,
        HeaderValue::from_static("text/plain; charset=utf-8"),
    );
    response
        .headers_mut()
        .insert(header::CONTENT_LENGTH, unsafe {
            HeaderValue::from_shared_unchecked(body_len.into())
        });
    err.headers(response.headers_mut());

    response
}
