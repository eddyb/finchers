//! The components to construct an asynchronous HTTP service from the `Endpoint`.

use std::future::Future;
use std::io;
use std::mem::PinMut;
use std::task;
use std::task::Poll;

use futures_core::future::TryFuture;
use futures_util::ready;
use http::header::HeaderValue;
use http::{header, Request, Response};

use error::NoRoute;
use generic::Either;
use input::body::ReqBody;
use input::{with_set_cx, Cursor, Input};
use output::payloads::Once;
use output::Responder;
use rt::AppEndpoint;

/// A factory of HTTP service which wraps an `Endpoint`.
#[derive(Debug)]
pub struct App<'a, E: AppEndpoint> {
    endpoint: &'a E,
}

impl<E: AppEndpoint> App<'a, E> {
    /// Create a new `App` from the provided components.
    pub fn new(endpoint: &'a E) -> App<'a, E> {
        App { endpoint }
    }

    #[allow(missing_docs)]
    pub fn new_service(&self) -> AppService<'a, E> {
        AppService {
            endpoint: self.endpoint,
        }
    }
}

/// An asynchronous HTTP service which holds an `Endpoint`.
///
/// The value of this type is generated by `NewEndpointService`.
#[derive(Debug)]
pub struct AppService<'a, E: AppEndpoint> {
    endpoint: &'a E,
}

impl<E: AppEndpoint> AppService<'a, E> {
    #[allow(missing_docs)]
    pub fn call(&mut self, request: Request<ReqBody>) -> AppFuture<'a, E> {
        AppFuture {
            state: State::Uninitialized,
            input: Input::new(request),
            endpoint: self.endpoint,
        }
    }
}

#[allow(missing_docs)]
#[derive(Debug)]
pub struct AppFuture<'a, E: AppEndpoint> {
    state: State<E::Future>,
    input: Input,
    endpoint: &'a E,
}

#[derive(Debug)]
enum State<T> {
    Uninitialized,
    InFlight(T),
    Gone,
}

impl<E: AppEndpoint> Future for AppFuture<'_, E> {
    type Output = io::Result<Response<Either<Once<String>, <E::Output as Responder>::Body>>>;

    fn poll(self: PinMut<'_, Self>, cx: &mut task::Context<'_>) -> Poll<Self::Output> {
        let this = unsafe { PinMut::get_mut_unchecked(self) };
        let mut input = unsafe { PinMut::new_unchecked(&mut this.input) };

        let output = loop {
            match this.state {
                State::Uninitialized => {
                    let result = {
                        let input = input.reborrow();
                        let cursor = unsafe { Cursor::new(&*(input.uri().path() as *const str)) };
                        this.endpoint.apply(input, cursor)
                    };
                    match result {
                        Some((future, _cursor)) => this.state = State::InFlight(future),
                        None => {
                            this.state = State::Gone;
                            break Err(NoRoute.into());
                        }
                    }
                }
                State::InFlight(ref mut f) => {
                    let f = unsafe { PinMut::new_unchecked(f) };
                    break ready!(with_set_cx(input.reborrow(), || f.try_poll(cx)));
                }
                State::Gone => panic!("cannot poll AppServiceFuture twice"),
            }
        };

        let mut response = output
            .and_then({
                let input = input.reborrow();
                |out| {
                    out.respond(input)
                        .map(|res| res.map(Either::Right))
                        .map_err(Into::into)
                }
            }).unwrap_or_else(|err| err.to_response().map(|body| Either::Left(Once::new(body))));

        response
            .headers_mut()
            .entry(header::SERVER)
            .unwrap()
            .or_insert(HeaderValue::from_static(concat!(
                "finchers-runtime/",
                env!("CARGO_PKG_VERSION")
            )));

        Poll::Ready(Ok(response))
    }
}

mod service {
    use super::{App, AppFuture, AppService};

    use std::boxed::PinBox;
    use std::io;

    use futures as futures01;
    use futures_util::compat::{Compat, TokioDefaultExecutor};
    use futures_util::try_future::TryFutureExt;
    use http::Request;
    use hyper::body::Body;
    use hyper::service::{NewService, Service};

    use generic::Either;
    use input::body::ReqBody;
    use output::payloads::Once;
    use output::Responder;
    use rt::AppEndpoint;

    impl<E: AppEndpoint> NewService for App<'a, E> {
        type ReqBody = Body;
        type ResBody = Either<Once<String>, <E::Output as Responder>::Body>;
        type Error = io::Error;
        type Service = AppService<'a, E>;
        type InitError = io::Error;
        type Future = futures01::future::FutureResult<Self::Service, Self::InitError>;

        fn new_service(&self) -> Self::Future {
            futures01::future::ok(self.new_service())
        }
    }

    impl<E: AppEndpoint> Service for AppService<'a, E> {
        type ReqBody = Body;
        type ResBody = Either<Once<String>, <E::Output as Responder>::Body>;
        type Error = io::Error;
        type Future = Compat<PinBox<AppFuture<'a, E>>, TokioDefaultExecutor>;

        fn call(&mut self, request: Request<Self::ReqBody>) -> Self::Future {
            PinBox::new(self.call(request.map(ReqBody::from_hyp))).compat(TokioDefaultExecutor)
        }
    }
}
