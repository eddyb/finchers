//! The components to construct an asynchronous HTTP service from the `Endpoint`.

use std::future::Future;
use std::io;
use std::mem::PinMut;
use std::task::{self, Poll};

use http::header::{self, HeaderValue};
use http::{Request, Response};

use futures_core::future::TryFuture;
use futures_util::ready;

use error::{Error, NoRoute};
use generic::Either;
use input::body::ReqBody;
use input::{with_set_cx, Cursor, Input};
use output::payloads::Once;
use output::Responder;
use runtime::AppEndpoint;

/// A factory of HTTP service which wraps an `Endpoint`.
#[derive(Debug)]
pub struct App<'a, E: AppEndpoint> {
    endpoint: &'a E,
}

impl<E: AppEndpoint> App<'a, E> {
    /// Create a new `App` from the provided components.
    pub fn new(endpoint: &'a E) -> App<'a, E> {
        App { endpoint }
    }

    #[allow(missing_docs)]
    pub fn new_service(&self) -> AppService<'a, E> {
        AppService {
            endpoint: self.endpoint,
        }
    }
}

/// An asynchronous HTTP service which holds an `Endpoint`.
///
/// The value of this type is generated by `NewEndpointService`.
#[derive(Debug)]
pub struct AppService<'a, E: AppEndpoint> {
    endpoint: &'a E,
}

impl<E: AppEndpoint> AppService<'a, E> {
    #[allow(missing_docs)]
    pub fn call(&mut self, request: Request<ReqBody>) -> AppServiceFuture<'a, E> {
        AppServiceFuture {
            input: Input::new(request),
            in_flight: None,
            endpoint: self.endpoint,
        }
    }
}

#[allow(missing_docs)]
#[derive(Debug)]
pub struct AppServiceFuture<'a, E: AppEndpoint> {
    input: Input,
    in_flight: Option<E::Future>,
    endpoint: &'a E,
}

impl<E: AppEndpoint> AppServiceFuture<'_, E> {
    fn handle_error(&self, err: Error) -> Response<Once<String>> {
        let mut response = Response::new(Once::new(format!("{:#}", err)));
        *response.status_mut() = err.status_code();
        response.headers_mut().insert(
            header::CONTENT_TYPE,
            HeaderValue::from_static("text/plain; charset=utf-8"),
        );
        err.headers(response.headers_mut());
        response
    }
}

impl<E: AppEndpoint> Future for AppServiceFuture<'_, E> {
    type Output = io::Result<Response<Either<Once<String>, <E::Output as Responder>::Body>>>;

    fn poll(self: PinMut<'_, Self>, cx: &mut task::Context<'_>) -> Poll<Self::Output> {
        let this = unsafe { PinMut::get_mut_unchecked(self) };

        let polled = loop {
            match this.in_flight {
                Some(ref mut f) => {
                    let f = unsafe { PinMut::new_unchecked(f) };
                    let input = unsafe { PinMut::new_unchecked(&mut this.input) };
                    break with_set_cx(input, || f.try_poll(cx));
                }
                None => {
                    this.in_flight = {
                        let input = unsafe { PinMut::new_unchecked(&mut this.input) };
                        let cursor = unsafe {
                            let path = &*(input.uri().path() as *const str);
                            Cursor::new(path)
                        };
                        this.endpoint
                            .apply(input, cursor)
                            .map(|(future, _cursor)| future)
                    };
                    if this.in_flight.is_none() {
                        break Poll::Ready(Err(NoRoute.into()));
                    }
                }
            }
        };

        let mut response = ready!(polled)
            .and_then(|out| {
                let input = unsafe { PinMut::new_unchecked(&mut this.input) };
                out.respond(input)
                    .map(|res| res.map(Either::Right))
                    .map_err(Into::into)
            }).unwrap_or_else(|err| this.handle_error(err).map(Either::Left));

        response
            .headers_mut()
            .entry(header::SERVER)
            .unwrap()
            .or_insert(HeaderValue::from_static(concat!(
                "finchers-runtime/",
                env!("CARGO_PKG_VERSION")
            )));

        Poll::Ready(Ok(response))
    }
}

mod service {
    use super::{App, AppService};

    use std::boxed::PinBox;
    use std::io;

    use futures::{self, Future};
    use http::{Request, Response};
    use hyper::body::Body;
    use hyper::service::{NewService, Service};

    use futures_util::compat::TokioDefaultExecutor;
    use futures_util::try_future::TryFutureExt;

    use generic::Either;
    use input::body::ReqBody;
    use output::payloads::Once;
    use output::Responder;
    use runtime::AppEndpoint;

    impl<E: AppEndpoint> NewService for App<'a, E> {
        type ReqBody = Body;
        type ResBody = Either<Once<String>, <E::Output as Responder>::Body>;
        type Error = io::Error;
        type Service = AppService<'a, E>;
        type InitError = io::Error;
        type Future = futures::future::FutureResult<Self::Service, Self::InitError>;

        fn new_service(&self) -> Self::Future {
            futures::future::ok(self.new_service())
        }
    }

    impl<E: AppEndpoint> Service for AppService<'a, E> {
        type ReqBody = Body;
        type ResBody = Either<Once<String>, <E::Output as Responder>::Body>;
        type Error = io::Error;
        type Future =
            Box<dyn Future<Item = Response<Self::ResBody>, Error = Self::Error> + Send + 'a>;

        fn call(&mut self, request: Request<Self::ReqBody>) -> Self::Future {
            Box::new(
                PinBox::new(self.call(request.map(ReqBody::from_hyp))).compat(TokioDefaultExecutor),
            )
        }
    }
}
